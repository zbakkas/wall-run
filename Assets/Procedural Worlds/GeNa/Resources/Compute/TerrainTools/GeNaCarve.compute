// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Carve
#include "../Includes/Fractal.cginc"

struct Sample
{
    float3 location;
    float3 scale;
    float timeInCurve;
};

struct Pivot
{
    uint U;
    uint I;
};

struct LUT
{
    float3 P;
    float t;
};

struct Curve
{
    float3 P0;
    float3 P1;
    float3 P2;
    float3 P3;
};

Texture2D<float> _InputDisplacement;
RWTexture2D<float> _OutputDisplacement;
RWTexture2D<float> _OutputSolidDisplacement;
StructuredBuffer<Pivot> _PivotTable;
StructuredBuffer<int> _HashTable;
StructuredBuffer<LUT> _LUT;
StructuredBuffer<Curve> _Curves;
StructuredBuffer<Curve> _ShoulderList;
StructuredBuffer<Sample> _SampleList;
uint _SampleCount = 0;
uint _CurveCount = 0;
uint _ShoulderListCount = 0;
//Variables
float _Edge = 0.03f;
float _Smooth = 0.0f;
float _Strength = 1.0f;
float2 _iResolution = 513.0f;
float2 _Offset = 0.0f;

float noiseStrength = 1.0f;
int fractalType = 0;
float seed = 0.0f;
int octaves = 1.0f;
float frequency = 0.05f;
float persistence = 0.65f;
float lacunarity = 1.5f;
float XOffset = 2.0f;
float ZOffset = 5.0f;
float YOffset = 7.0f;

Sample SampleLerp(Sample a, Sample b, float t)
{
    Sample result;
    result.location = lerp(a.location, b.location, t);
    result.scale = lerp(a.scale, b.scale, t);
    result.timeInCurve = t;
    //TODO : Manny : You can add more logic here
    return result;
}

bool SampleEquals(Sample a, Sample b)
{
    return a.timeInCurve == b.timeInCurve;
}

Sample GetSample(float time)
{
    int prevIndex = 0;
    int nextIndex = 0;
    for (uint i = 0; i < _SampleCount; i++)
    {
        Sample current = _SampleList[i];
        if (current.timeInCurve >= time)
        {
            nextIndex = i;
            break;
        }
        prevIndex = i;
    }
    Sample previous = _SampleList[prevIndex];
    Sample next = _SampleList[nextIndex];
    float t = SampleEquals(next, previous) ? 0.0f : (time - previous.timeInCurve) / (next.timeInCurve - previous.timeInCurve);
    return SampleLerp(previous, next, t);
}

//-----------------------------------------------------------------------------
float3 Bezier(float t)
{
    int index = (int)floor(t);
    t = t - index;
    Curve curve = _Curves[index];
    float omt = 1.0f - t;
    float omt2 = omt * omt;
    float t2 = t * t;
    float3 b = curve.P0 * (omt2 * omt) +
        curve.P1 * (3.0f * omt2 * t) +
        curve.P2 * (3.0f * omt * t2) +
        curve.P3 * (t2 * t);
    return b;
}

Sample GetClosestSample(LUT closestLUT, float2 coordinate)
{
    float time = closestLUT.t;
    float u = 0.125f;
    float minTime = max(0.0f, time - u);
    float maxTime = min(_CurveCount, time + u);
    float minDistance = 1e10f;
    float3 minLocation = float3(0.0f, 0.0f, 0.0f);
    float closestTime = time;
    while (minTime < maxTime)
    {
        float3 location = Bezier(minTime);
        float normalizedDistance = length(location.xz - coordinate.xy);
        if (normalizedDistance < minDistance)
        {
            minLocation = location;
            minDistance = normalizedDistance;
            closestTime = minTime;
        }
        minTime += 0.001f;
    }
    Sample result = GetSample(closestTime);
    result.location = minLocation;
    return result;
}

float GetNoise(float3 position)
{
    Fractal fractal;
    fractal.type = fractalType;
    fractal.frequency = frequency;
    fractal.seed = seed;
    fractal.xOffset = XOffset;
    fractal.yOffset = YOffset;
    fractal.zOffset = ZOffset;
    fractal.persistence = persistence;
    fractal.octaves = octaves;
    fractal.lacunarity = lacunarity;
    return Fractal_GetNormalisedValue(fractal, position.x, position.z);
}

float BezierShoulder(float t)
{
    int i;
    if (t >= 1.0f)
    {
        t = 1.0f;
        i = _ShoulderListCount;
    }
    else
    {
        t = clamp(t, 0.0f, 1.0f) * _ShoulderListCount;
        i = (int)t;
        t -= i;
    }
    Curve curve = _ShoulderList[i];
    float omt = 1.0f - t;
    float omt2 = omt * omt;
    float t2 = t * t;
    float3 b = curve.P0 * (omt2 * omt) +
        curve.P1 * (3.0f * omt2 * t) +
        curve.P2 * (3.0f * omt * t2) +
        curve.P3 * (t2 * t);
    return b.y;
}

[numthreads(16,16,1)]
void Carve(uint3 id : SV_DispatchThreadID)
{
    uint2 coord = id.xy;
    float2 coordinate = ((float2)coord + _Offset) / _iResolution.xy;
    float resX = _iResolution.x;
    float resY = _iResolution.y;
    float xRes = coordinate.x * resX;
    float yRes = coordinate.y * resY;
    float3 worldPos = float3(xRes, 0.f, yRes);
    float baseHeight = _InputDisplacement[coord];
    float solidDisplacement = 0.0f;
    float smooth = _Smooth;
    float edge = _Edge;
    //---------------
    Pivot pivot = _PivotTable[0];
    if (pivot.U != 0)
    {
        float displacement = 0.0f;
        LUT closestLUT;
        closestLUT.P = float3(0.0f, 0.0f, 0.0f);
        closestLUT.t = 0.0f;
        float minDistance = 1e10f;
        for (int i = pivot.U; i >= 0; i--)
        {
            int hash = _HashTable[pivot.I + i];
            LUT lut = _LUT[hash];
            float distance = length(lut.P.xz - coordinate.xy);
            if (distance < minDistance)
            {
                closestLUT = lut;
                minDistance = distance;
            }
        }
        Sample closestSample = GetClosestSample(closestLUT, coordinate);
        edge *= closestSample.scale.x;
        smooth *= closestSample.scale.x;
        float sqrSmooth = smooth * smooth;
        float cutoff = edge + sqrSmooth;
        float proximity = cutoff / resX;
        float3 location = closestSample.location;
        float normalizedDistance = length(location.xz - coordinate.xy);
        float noise = GetNoise(worldPos); // 0 - 1
        // This will get called for EVERY point along the spline within the radius of MinDistance
        if (normalizedDistance < proximity)
        {
            // Get Height at Location
            displacement = location.y * .5f - baseHeight;
            solidDisplacement = 1.0f;
        }
        float denormDistance = normalizedDistance * resX;
        if (denormDistance < cutoff && smooth > 0.0f)
        {
            float shoulderPos = denormDistance - edge;
            if (shoulderPos > 0.0f)
            {
                float normalizedShoulderPos = (sqrSmooth - shoulderPos) / sqrSmooth;
                if (normalizedShoulderPos > 0.0f)
                {
                    float delta = smoothstep(0.0f, 1.0f, normalizedShoulderPos);
                    float strength = noiseStrength / resX;
                    float deltaRes = 1.0f - delta;
                    displacement += noise * deltaRes * (strength * BezierShoulder(deltaRes).x);
                    displacement *= delta;
                    solidDisplacement = 1.0f;
                    solidDisplacement -= round(noise * noiseStrength);
                }
            }
        }
        _OutputDisplacement[coord] = baseHeight + displacement;
        _OutputSolidDisplacement[coord] = solidDisplacement * _Strength;
    }
}
